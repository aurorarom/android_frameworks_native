diff a/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/services/surfaceflinger/DisplayHardware/HWComposer.cpp	(rejected hunks)
@@ -190,6 +195,18 @@ HWComposer::HWComposer(
         // we don't have VSYNC support, we need to fake it
         mVSyncThread = new VSyncThread(*this);
     }
+
+#ifdef MTK_AOSP_ENHANCEMENT
+    for (size_t i = 0; i<MAX_HWC_DISPLAYS; i++) {
+        mDisplayData[i].mirrorId = -1;
+    }
+
+    // query features state from HWC module
+    memset(&mFeaturesState, 0, sizeof(hwc_feature_t));
+    if (mHwc) {
+        mHwc->query(mHwc, HWC_FEATURES_STATE, (int *)&mFeaturesState);
+    }
+#endif
 }
 
 HWComposer::~HWComposer() {
@@ -333,6 +354,9 @@ static const uint32_t DISPLAY_ATTRIBUTES[] = {
     HWC_DISPLAY_HEIGHT,
     HWC_DISPLAY_DPI_X,
     HWC_DISPLAY_DPI_Y,
+#ifdef MTK_AOSP_ENHANCEMENT
+    HWC_DISPLAY_SUBTYPE,
+#endif
     HWC_DISPLAY_NO_ATTRIBUTE,
 };
 #define NUM_DISPLAY_ATTRIBUTES (sizeof(DISPLAY_ATTRIBUTES) / sizeof(DISPLAY_ATTRIBUTES)[0])
@@ -383,6 +407,11 @@ status_t HWComposer::queryDisplayProperties(int disp) {
                 case HWC_DISPLAY_DPI_Y:
                     config.ydpi = values[i] / 1000.0f;
                     break;
+#ifdef MTK_AOSP_ENHANCEMENT
+                case HWC_DISPLAY_SUBTYPE:
+                    mDisplayData[disp].subtype = values[i];
+                    break;
+#endif
                 default:
                     ALOG_ASSERT(false, "unknown display attribute[%zu] %#x",
                             i, DISPLAY_ATTRIBUTES[i]);
@@ -632,6 +661,9 @@ status_t HWComposer::setFramebufferTarget(int32_t id,
 }
 
 status_t HWComposer::prepare() {
+#ifdef MTK_AOSP_ENHANCEMENT
+    ATRACE_CALL();
+#endif
     for (size_t i=0 ; i<mNumDisplays ; i++) {
         DisplayData& disp(mDisplayData[i]);
         if (disp.framebufferTarget) {
