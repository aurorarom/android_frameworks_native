diff a/cmds/installd/commands.c b/cmds/installd/commands.c	(rejected hunks)
@@ -21,6 +26,12 @@
 #include <diskusage/dirsize.h>
 #include <selinux/android.h>
 
+#define CALCULATE_DIRECTORY_REAL_SIZE
+
+#ifdef MTK_OAT_ON_SDCARD_SUPPORT
+dir_rec_t android_ext_dalvik_cache_dir;
+#endif
+
 /* Directory records that are used in execution of commands. */
 dir_rec_t android_data_dir;
 dir_rec_t android_asec_dir;
@@ -1363,6 +1519,127 @@ out:
     return rc;
 }
 
+#ifdef MTK_OAT_ON_SDCARD_SUPPORT
+int move_oat(const char *src, const char *instruction_set, uid_t uid, int is_public)
+{
+    char src_oat[PKG_PATH_MAX];
+    char dst_oat[PKG_PATH_MAX];
+
+    if (validate_apk_path(src)) return -1;
+
+    //TODO: need verify by ALPS01381881
+    //run cts -p android.tests.appsecurity
+    if(strstr(src, "/mnt/asec") == NULL){
+        ALOGI("only move_oat installed on /mnt/asec");
+        return -1;
+    }
+
+    if (create_cache_path(src_oat, src, instruction_set)) return -1;
+    if (create_ext_cache_path(dst_oat, src)) return -1;
+
+    ALOGD("move_oat %s -> %s", src_oat, dst_oat);
+
+    struct stat st;
+    char oat_path[PKG_PATH_MAX];
+
+    memset(oat_path, 0x00, PKG_PATH_MAX);
+
+    if (lstat(src_oat, &st) < 0) {
+        if (errno != ENOENT) {
+            ALOGE("couldn't stat %s : %s", src_oat, strerror(errno));
+            return -1;
+        }
+    } else {
+        if (S_ISLNK(st.st_mode)) {
+            ALOGE("No need to move link_to_oat : %s", src_oat);
+            return 0;
+        }
+    }           
+
+    int fi, fo;
+    char buf[1024];
+    int rlen, wlen;
+
+    fi = open(src_oat, O_RDONLY, 0);
+    fo = open(dst_oat, O_RDWR | O_CREAT | O_EXCL, 0644);
+
+    if (fi < 0)  {
+        ALOGE("move_oat: cannot open '%s'(%s) for input\n", src_oat, strerror(errno));
+        return  -1;
+    }
+
+    if (fo < 0)  {
+        ALOGE("move_oat: cannot open '%s'(%s) for output\n", dst_oat, strerror(errno));
+        close(fi);
+        return  -1;
+    }
+
+    if ((fi > 0 ) && (fo > 0))  {
+
+        if (fchmod(fo,
+                    S_IRUSR|S_IWUSR|S_IRGRP |
+                    (is_public ? S_IROTH : 0)) < 0) {
+            ALOGE("cannot chmod '%s' : %s\n", dst_oat, strerror(errno));
+            //return -1;
+        }
+
+        if (fchown(fo, AID_SYSTEM, uid) < 0) {
+            ALOGE("cannot chown '%s' : %s\n", dst_oat,strerror(errno));
+            //return -1;
+        }
+
+        do  {
+            rlen = read(fi, buf, 1024);
+            wlen = write(fo, buf, rlen);
+            if (rlen != wlen)  {
+                ALOGE("Couldn't move %s -> %s : %s\n", src_oat, dst_oat, strerror(errno));
+                close(fi);
+                close(fo);
+                return -1;
+            }
+        } while (rlen == 1024);
+    }
+
+    if (fi)
+        close(fi);
+    if (fo)
+        close(fo);
+
+    ALOGD("unlink %s\n", src_oat);
+    if (unlink(src_oat) < 0) {
+        ALOGE("Couldn't unlink %s: %s\n", src_oat, strerror(errno));
+        return -1;
+    }
+
+    ALOGD("symlink %s\n", src_oat);
+    if (symlink(dst_oat, src_oat) < 0) {
+        ALOGE("couldn't symlink '%s' -> '%s': %s\n", src_oat, dst_oat, strerror(errno));
+        return -1;
+    }
+
+    return 0;
+}
+#endif
+
+/// M: [PMS Recovery] Implement of change uid function
+int change_uid_root(const char* pkgname, int userId) {
+    char pkgdir[PKG_PATH_MAX];
+    struct stat s;
+    if (create_pkg_path(pkgdir, pkgname, PKG_DIR_POSTFIX, userId)) {
+        ALOGE("cannot create package path\n");
+        return -1;
+    }
+    if (stat(pkgdir, &s) < 0) return -1;
+
+    if (s.st_uid != 0 || s.st_gid != 0) {
+        if (chown(pkgdir, 0, 0) < 0) {
+            ALOGE("failed to chown '%s': %s\n", pkgdir, strerror(errno));
+            return -1;
+        }
+    }
+    
+    return 0;
+}
 static void run_idmap(const char *target_apk, const char *overlay_apk, int idmap_fd)
 {
     static const char *IDMAP_BIN = "/system/bin/idmap";
